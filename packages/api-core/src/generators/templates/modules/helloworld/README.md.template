# HelloWorld Module - CRUD Example with Views

This module demonstrates a complete CRUD API implementation with advanced database features including regular views and materialized views.

## üìã Overview

The HelloWorld module showcases:
- **Complete CRUD operations** with validation and error handling
- **Regular database views** for real-time analytics
- **Materialized views** for high-performance reporting
- **Soft delete functionality** with restore capability
- **Pagination and filtering** with search capabilities
- **Load testing** configuration and examples
- **Comprehensive API documentation** with Swagger

## üèóÔ∏è Architecture

### Entities & Views

#### 1. HelloWorldItem (Base Table)
```typescript
// Standard database table with full CRUD operations
@Entity('helloworld_items')
export class HelloWorldItem {
  id: string;           // UUID primary key
  name: string;         // Item name (max 255 chars)
  description: string;  // Optional description
  category: string;     // Item category
  status: enum;         // active | inactive | pending
  price: number;        // Decimal(10,2)
  quantity: number;     // Integer
  createdAt: Date;      // Auto-generated
  updatedAt: Date;      // Auto-updated
  deletedAt: Date;      // Soft delete support
}
```

#### 2. HelloWorldSummaryView (Regular View)
```sql
-- Real-time summary by category
-- Always current data, executes query each time
CREATE VIEW helloworld_summary_view AS
SELECT 
  category,
  COUNT(*) as total_items,
  COUNT(CASE WHEN status = 'active' THEN 1 END) as active_items,
  AVG(price) as average_price,
  SUM(quantity) as total_quantity,
  MIN(created_at) as first_item_date,
  MAX(updated_at) as last_updated
FROM helloworld_items 
WHERE deleted_at IS NULL
GROUP BY category;
```

**Regular View Characteristics:**
- ‚úÖ Always shows current data (real-time)
- ‚úÖ No storage overhead (virtual table)
- ‚úÖ Automatically reflects changes
- ‚ùå Slower for complex queries
- ‚ùå Performance depends on base table size

**Best for:** Real-time dashboards, simple aggregations, frequently changing data

#### 3. HelloWorldStatsView (Materialized View)
```sql
-- Pre-computed analytics with advanced statistics
-- Stored results, refreshed periodically
CREATE MATERIALIZED VIEW helloworld_stats_materialized_view AS
SELECT 
  DATE_TRUNC('day', created_at) as date,
  category,
  status,
  COUNT(*) as item_count,
  SUM(price * quantity) as total_value,
  AVG(price) as avg_price,
  PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY price) as median_price,
  STDDEV(price) as price_std_dev,
  -- Trend analysis
  LAG(COUNT(*)) OVER (PARTITION BY category ORDER BY DATE_TRUNC('day', created_at)) as prev_day_count,
  COUNT(*) - LAG(COUNT(*)) OVER (...) as daily_change
FROM helloworld_items 
WHERE deleted_at IS NULL
GROUP BY DATE_TRUNC('day', created_at), category, status;
```

**Materialized View Characteristics:**
- ‚úÖ Very fast query performance (pre-computed)
- ‚úÖ Great for complex analytics
- ‚úÖ Supports advanced SQL functions
- ‚ùå Data may be stale (refresh dependent)
- ‚ùå Additional storage overhead
- ‚ùå Slower refresh process

**Best for:** Complex reporting, analytics dashboards, historical analysis, read-heavy workloads

## üîÑ View Comparison

| Feature | Regular View | Materialized View |
|---------|-------------|-------------------|
| **Data Freshness** | Always current | Potentially stale |
| **Query Performance** | Depends on complexity | Very fast |
| **Storage** | No overhead | Additional storage |
| **Refresh** | Automatic | Manual/Scheduled |
| **Complex Analytics** | Limited by real-time constraints | Full SQL capabilities |
| **Use Case** | Real-time dashboards | Performance-critical reporting |

## üöÄ API Endpoints

### CRUD Operations
```bash
# Create item
POST /api/helloworld
{
  "name": "Sample Item",
  "description": "This is a sample item",
  "category": "electronics",
  "status": "active",
  "price": 29.99,
  "quantity": 100
}

# Get all items with filtering
GET /api/helloworld?category=electronics&status=active&page=1&limit=10&search=sample

# Get single item
GET /api/helloworld/{id}

# Update item
PATCH /api/helloworld/{id}
{
  "name": "Updated Item",
  "price": 39.99
}

# Soft delete item
DELETE /api/helloworld/{id}

# Restore deleted item
POST /api/helloworld/{id}/restore
```

### Analytics Endpoints

#### Real-time Analytics (Regular View)
```bash
# Get current summary by category
GET /api/helloworld/analytics/summary
GET /api/helloworld/analytics/summary?category=electronics

# Get top categories
GET /api/helloworld/analytics/top-categories?limit=5
```

#### Performance Analytics (Materialized View)
```bash
# Get historical statistics
GET /api/helloworld/analytics/stats
GET /api/helloworld/analytics/stats?category=electronics&startDate=2024-01-01&endDate=2024-12-31

# Get trend analysis
GET /api/helloworld/analytics/trends?days=30

# Manually refresh materialized view
POST /api/helloworld/analytics/refresh
```

## ‚ö° Performance Considerations

### When to Use Regular Views
- Real-time dashboards requiring current data
- Simple aggregations over small datasets
- When data consistency is critical
- Frequently changing data that needs immediate reflection

### When to Use Materialized Views
- Complex analytics and reporting
- Large datasets with expensive calculations
- Read-heavy workloads
- Historical trend analysis
- Performance-critical queries

### Refresh Strategies

#### Automatic Refresh (Scheduled)
```typescript
// Runs every hour via cron job
@Cron(CronExpression.EVERY_HOUR)
async scheduledMaterializedViewRefresh() {
  await this.repository.refreshMaterializedView();
}
```

#### Manual Refresh (On-Demand)
```typescript
// Refresh after significant data changes
async create(createDto: CreateHelloWorldItemDto) {
  const item = await this.repository.create(createDto);
  await this.refreshStatsIfNeeded(); // Refresh materialized view
  return item;
}
```

#### Batch Refresh (Production Recommended)
```typescript
// Use job queues for production
// - Queue refresh requests
// - Batch multiple changes
// - Run during off-peak hours
```

## üß™ Testing

### Unit Tests
```bash
npm run test:unit
```

### Integration Tests
```bash
npm run test:e2e
```

### Load Testing
```bash
# Quick load test
npm run load:quick

# Full load test with reporting
npm run load:test
npm run load:report

# Stress testing
npm run load:stress
```

### Load Test Scenarios
1. **Health Check Flow** (10%) - Basic health endpoint testing
2. **CRUD Flow** (40%) - Create, read, update, delete operations
3. **Analytics Flow** (30%) - Real-time and materialized view queries
4. **Create/Update Flow** (20%) - Heavy write operations

## üìä Monitoring

### Key Metrics to Monitor

#### Regular View Performance
- Query execution time
- CPU usage during view queries
- Concurrent view access

#### Materialized View Performance
- Refresh duration
- Storage usage growth
- Query response time
- Refresh frequency vs data freshness

### Optimization Tips

#### For Regular Views
```sql
-- Add indexes on frequently filtered columns
CREATE INDEX idx_helloworld_category ON helloworld_items(category);
CREATE INDEX idx_helloworld_status ON helloworld_items(status);
CREATE INDEX idx_helloworld_created_at ON helloworld_items(created_at);
```

#### For Materialized Views
```sql
-- Add indexes on materialized view columns
CREATE INDEX idx_stats_date_category ON helloworld_stats_materialized_view(date, category);
CREATE INDEX idx_stats_category ON helloworld_stats_materialized_view(category);
```

## üîß Configuration

### Environment Variables
```bash
# Materialized view refresh settings
MATERIALIZED_VIEW_REFRESH_INTERVAL=3600  # seconds
MATERIALIZED_VIEW_AUTO_REFRESH=true

# Performance settings
MAX_QUERY_RESULTS=1000
DEFAULT_PAGE_SIZE=10
MAX_PAGE_SIZE=100
```

### Production Recommendations

1. **Refresh Strategy**
   - Schedule materialized view refreshes during off-peak hours
   - Use incremental refresh when possible
   - Monitor refresh performance and adjust frequency

2. **Indexing**
   - Add appropriate indexes on base tables
   - Index materialized view columns used in WHERE clauses
   - Monitor query plans and optimize accordingly

3. **Monitoring**
   - Set up alerts for long-running refresh operations
   - Monitor storage growth of materialized views
   - Track query performance metrics

4. **Scaling**
   - Consider partitioning for very large datasets
   - Use read replicas for analytics queries
   - Implement caching for frequently accessed data

## üìö Learning Resources

- [PostgreSQL Views Documentation](https://www.postgresql.org/docs/current/sql-createview.html)
- [Materialized Views Best Practices](https://www.postgresql.org/docs/current/sql-creatematerializedview.html)
- [TypeORM View Entities](https://typeorm.io/view-entities)
- [NestJS CRUD Best Practices](https://docs.nestjs.com/techniques/database)